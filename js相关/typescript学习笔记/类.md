类的成员可声明为 public,private,protected
类里面的属性默认为 public
private 的属性只能在类内部访问，外部访问不到

```javascript
class Animal {
    private name: string;
    constructor(theName: string) { this.name = theName; }
}

new Animal("Cat").name; // 错误: 'name' 是私有的.
```

protected 的属性与 private 相似，不过 protected 的属性在派生类当中也可访问

```javascript
class Animal {
  protected name: string
  constructor(theName: string) { this.name = theName; }
}

class Dog extends Animal {
  constructor(theName: string) {
    super(theName)
  }
  say() {
    console.log(`my name is ${this.name}`)
  }
}
let dog = new Dog('wangcai')
let animal = new Animal('horse')
dog.say()
console.log(animal.name) // 报错，不能直接访问
```

readonly 属性在实例化后就不能更改了

参数属性

```javascript
class Animal {
    constructor(private name: string) {}

    sayName() {
      console.log(this.name)
    }
}
let animal = new Animal('dog')
animal.sayName()
```

存取器:支持自定义 getters/setters 限制对对象成员的访问

```javascript
let nameEditable = false
class People {
  constructor(private _name: string) {}

  get name() {
    return this._name
  }

  set name(newName: string) {
    if (nameEditable) {
      this._name = newName
    } else {
      console.log('the name can not change')
    }
  }
}

let p = new People('tom')
p.name = 'jim' // 这里会打印the name can not change
console.log(p.name)
```

注:ts 会把存取器语法编译成 Object.defineProperty，该语法只支持 es5 及更高版本的语法环境，所以该语法只能用于支持 es5 或更高的编译环境

静态属性

```javascript
class People {
  static sex: string = 'male'
}
console.log(People.sex)
```

抽象类：由 abstract 关键字定义，定义成员的实现细节，不包含具体实现，不能直接实例化，一般由子类继承后实例化
